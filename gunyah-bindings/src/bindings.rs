// Copyright (c) 2024, Qualcomm Innovation Center, Inc. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause-Clear

#![allow(clippy::missing_safety_doc)]
#![allow(clippy::upper_case_acronyms)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen 0.71.1 */

pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const GUNYAH_IOCTL_TYPE: u32 = 71;
pub const GUNYAH_FN_MAX_ARG_SIZE: u32 = 256;
pub const GUNYAH_MEM_ACCESS_MASK: u32 = 7;
pub const GUNYAH_VM_BOOT_CONTEXT_REG_SHIFT: u32 = 8;
pub const GUNYAH_VM_MAX_EXIT_REASON_SIZE: u32 = 8;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __sum16 = u16;
pub type __wsum = u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub mod gunyah_mem_flags {
    pub type Type = ::std::os::raw::c_uint;
    pub const GHMF_CLOEXEC: Type = 1;
    pub const GHMF_ALLOW_HUGEPAGE: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_create_mem_args {
    pub flags: u64,
    pub size: u64,
    pub reserved: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_vm_dtb_config {
    pub guest_phys_addr: u64,
    pub size: u64,
}
pub mod gunyah_fn_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const GUNYAH_FN_VCPU: Type = 1;
    pub const GUNYAH_FN_IRQFD: Type = 2;
    pub const GUNYAH_FN_IOEVENTFD: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_fn_vcpu_arg {
    pub id: u32,
}
pub mod gunyah_irqfd_flags {
    pub type Type = ::std::os::raw::c_uint;
    pub const GUNYAH_IRQFD_FLAGS_LEVEL: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_fn_irqfd_arg {
    pub fd: u32,
    pub label: u32,
    pub flags: u32,
    pub padding: u32,
}
pub mod gunyah_ioeventfd_flags {
    pub type Type = ::std::os::raw::c_uint;
    pub const GUNYAH_IOEVENTFD_FLAGS_DATAMATCH: Type = 1;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_fn_ioeventfd_arg {
    pub datamatch: u64,
    pub addr: u64,
    pub len: u32,
    pub fd: i32,
    pub flags: u32,
    pub padding: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_fn_desc {
    pub type_: u32,
    pub arg_size: u32,
    pub arg: u64,
}
pub mod gunyah_map_flags {
    pub type Type = ::std::os::raw::c_uint;
    pub const GUNYAH_MEM_DEFAULT_ACCESS: Type = 0;
    pub const GUNYAH_MEM_FORCE_LEND: Type = 1;
    pub const GUNYAH_MEM_FORCE_SHARE: Type = 2;
    pub const GUNYAH_MEM_ALLOW_READ: Type = 16;
    pub const GUNYAH_MEM_ALLOW_WRITE: Type = 32;
    pub const GUNYAH_MEM_ALLOW_EXEC: Type = 64;
    pub const GUNYAH_MEM_ALLOW_RWX: Type = 112;
    pub const GUNYAH_MEM_UNMAP: Type = 256;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_map_mem_args {
    pub guest_addr: u64,
    pub flags: u32,
    pub guest_mem_fd: u32,
    pub offset: u64,
    pub size: u64,
}
pub mod gunyah_vm_boot_context_reg {
    pub type Type = ::std::os::raw::c_uint;
    pub const REG_SET_X: Type = 0;
    pub const REG_SET_PC: Type = 1;
    pub const REG_SET_SP: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_vm_boot_context {
    pub reg: u32,
    pub reserved: u32,
    pub value: u64,
}
pub mod gunyah_vm_status {
    pub type Type = ::std::os::raw::c_uint;
    pub const GUNYAH_VM_STATUS_LOAD_FAILED: Type = 1;
    pub const GUNYAH_VM_STATUS_EXITED: Type = 2;
    pub const GUNYAH_VM_STATUS_CRASHED: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_vm_exit_info {
    pub type_: u16,
    pub padding: u16,
    pub reason_size: u32,
    pub reason: [u8; 8usize],
}
pub mod gunyah_vcpu_exit {
    pub type Type = ::std::os::raw::c_uint;
    pub const GUNYAH_VCPU_EXIT_UNKNOWN: Type = 0;
    pub const GUNYAH_VCPU_EXIT_MMIO: Type = 1;
    pub const GUNYAH_VCPU_EXIT_STATUS: Type = 2;
    pub const GUNYAH_VCPU_EXIT_PAGE_FAULT: Type = 3;
}
pub mod gunyah_vcpu_resume_action {
    pub type Type = ::std::os::raw::c_uint;
    pub const GUNYAH_VCPU_RESUME_HANDLED: Type = 0;
    pub const GUNYAH_VCPU_RESUME_FAULT: Type = 1;
    pub const GUNYAH_VCPU_RESUME_RETRY: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gunyah_vcpu_run {
    pub immediate_exit: u8,
    pub padding: [u8; 7usize],
    pub exit_reason: u32,
    pub __bindgen_anon_1: gunyah_vcpu_run__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gunyah_vcpu_run__bindgen_ty_1 {
    pub mmio: gunyah_vcpu_run__bindgen_ty_1__bindgen_ty_1,
    pub status: gunyah_vcpu_run__bindgen_ty_1__bindgen_ty_2,
    pub page_fault: gunyah_vcpu_run__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_vcpu_run__bindgen_ty_1__bindgen_ty_1 {
    pub phys_addr: u64,
    pub data: [u8; 8usize],
    pub len: u32,
    pub is_write: u8,
    pub resume_action: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gunyah_vcpu_run__bindgen_ty_1__bindgen_ty_2 {
    pub status: gunyah_vm_status::Type,
    pub exit_info: gunyah_vm_exit_info,
}
impl Default for gunyah_vcpu_run__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gunyah_vcpu_run__bindgen_ty_1__bindgen_ty_3 {
    pub phys_addr: u64,
    pub attempt: i32,
    pub resume_action: u8,
}
impl Default for gunyah_vcpu_run__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for gunyah_vcpu_run {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
